{
  "name": "async-mixin",
  "version": "0.0.1",
  "description": "caolin/async's collection methods as a mixin.",
  "main": "index.js",
  "scripts": {
    "test": "node test/index.js"
  },
  "author": {
    "name": "Tim Oxley"
  },
  "license": "MIT",
  "devDependencies": {
    "tape": "~2.0.0"
  },
  "dependencies": {
    "async": "~0.2.9"
  },
  "directories": {
    "test": "test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/timoxley/async-mixin.git"
  },
  "bugs": {
    "url": "https://github.com/timoxley/async-mixin/issues"
  },
  "readme": "# async-mixin\n\n### [caolin/async](https://github.com/caolan/async)'s collection methods as a mixin.\n\nMixin methods: \n\n* each\n* eachSeries\n* eachLimit\n* map\n* mapSeries\n* mapLimit\n* filter\n* filterSeries\n* reject\n* rejectSeries\n* reduce\n* reduceRight\n* detect\n* detectSeries\n* sortBy\n* some\n* every\n* concat\n* concatSeries\n\n\n## Examples\n\n### Wrap an object's array:\n\n```js\nvar admins = {\n  userIds: [1,2,3,4,5]\n}\n\n// pass target object + path to the array you want to\n// enumerate over asynchronously\nvar adminApi = asyncMixin(admins, 'userIds')\n\n// adminApi has all of the async collection methods:\nObject.keys(adminApi) // each, eachSeries, eachLimit, map, ...etc\n\n// async methods work just like caolin/async's methods,\n// except they're automatically bound to admins' 'userIds' property\nadminApi.map(function(userId, next) {\n  // pretend this is how we load a user\n  db.load(userId, next)\n}, function(err, users) {\n  // users is an array of results from our async operation db.load!\n})\n\n```\n\n### Optionally only include particular async methods\n\n```js\nvar admins = {\n  userIds: [1,2,3,4,5]\n}\n\nvar adminApi = asyncMixin(admins, 'userIds', ['map', 'filter'])\n\nObject.keys(adminApi) // ['map', 'filter']\n\nadminApi.map // => [Function]\nadminApi.filter // => [Function]\nadminApi.reduce // => undefined\n\n```\n\n\n### Wrap Arrays directly\n\n```js\n\nvar asyncMixin = require('async-mixin')\n\nvar items = [1,2,3,4,5]\n\nvar container = asyncMixin(items)\n\n// container now has all of async's methods\n// bound automatically to the passed-in items:\ncontainer.map(function(item, next) {\n  return next(null, item * 2)\n}, function(err, result) {\n  console.log(result) // => [2, 4, 6, 8, 10]\n})\n\n```\n\n### Create handy prototype objects\n\n```js\n\nfunction UserCollection(users) {\n  this.users = users\n}\n\nUserCollection.prototype = asyncMixin('users')\n\nUserCollection.prototype.save = function save(done) {\n  // pretend db.save is some async operation that saves users\n  this.forEach(db.save, done)\n}\n\nUserCollection.prototype.loadProfiles = function loadProfiles(done) {\n  // pretend db.loadProfile is some async operation that loads user profiles\n  this.map(db.loadProfile, done)\n}\n\nvar users = new UserCollection([{name: 'Bill'}, {name: 'Bob'}])\n\nusers.loadProfiles(function(err, profiles) {\n  // profies will be an array of results from db.loadProfile\n})\n\nusers.save(function(err) {\n  // if there was an error saving any user,\n  // err will contain that error\n})\n\n```\n\n### Safety\n\n`async-mixin` does not modify your original object, it simply returns a new\nobject that inherits from your original object, while adding async methods:\n\n```js\nvar admins = {\n  userIds: [1,2,3,4,5]\n}\n\nvar adminApi = asyncMixin(admins, 'userIds')\n\nadminApi.map // => [Function]\nadmins.map //  => undefined\n\n```\n\n## Inspiration\n\nSimilar idea to [component/enumerable](https://github.com/component/enumerable), but our enumeration methods are asynchronous.\n\n## Licence\n\nMIT\n",
  "readmeFilename": "Readme.md",
  "homepage": "https://github.com/timoxley/async-mixin",
  "_id": "async-mixin@0.0.1",
  "dist": {
    "shasum": "ec05a6cbb4858e687e555b4b6e99284f1b7b3b80"
  },
  "_from": "async-mixin@0.0.1",
  "_resolved": "https://registry.npmjs.org/async-mixin/-/async-mixin-0.0.1.tgz"
}
