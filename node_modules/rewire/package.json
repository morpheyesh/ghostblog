{
  "name": "rewire",
  "version": "2.0.1",
  "description": "Easy dependency injection for node.js unit testing",
  "keywords": [
    "dependency",
    "injection",
    "mock",
    "shim",
    "module",
    "unit",
    "test",
    "leak",
    "inspect"
  ],
  "author": {
    "name": "Johannes Ewald",
    "email": "mail@johannesewald.de"
  },
  "main": "lib/index.js",
  "homepage": "https://github.com/jhnns/rewire",
  "bugs": {
    "url": "https://github.com/jhnns/rewire/issues",
    "email": "mail@johannesewald.de"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jhnns/rewire.git"
  },
  "devDependencies": {
    "mocha": "1.x",
    "expect.js": "0.x",
    "coffee-script": "1.x"
  },
  "scripts": {
    "test": "node node_modules/mocha/bin/mocha -R spec",
    "coverage": "istanbul cover ./node_modules/mocha/bin/_mocha"
  },
  "readme": "rewire\r\n=====\r\n**Easy dependency injection for node.js unit testing**.\r\n\r\nrewire adds a special setter and getter to modules so you can modify their behaviour for better unit testing. You may\r\n\r\n- inject mocks for other modules or globals like `process`\r\n- leak private variables\r\n- override variables within the module.\r\n\r\nrewire does **not** load the file and eval the contents to emulate node's require mechanism. In fact it uses node's own\r\nrequire to load the module. Thus your module behaves exactly the same in your test environment as under regular\r\ncircumstances (except your modifications).\r\n\r\nGood news to all caffeine-addicts: rewire works also with [Coffee-Script](http://coffeescript.org/). Note that in this\r\ncase CoffeeScript needs to be listed in your devDependencies.\r\n\r\nIf you want to use rewire also on the client-side take a look at [client-side bundlers](https://github.com/jhnns/rewire#client-side-bundlers)\r\n\r\n[![Build Status](https://travis-ci.org/jhnns/rewire.svg?branch=master)](http://travis-ci.org/jhnns/rewire)\r\n[![Dependency Status](https://david-dm.org/jhnns/rewire.svg)](https://david-dm.org/jhnns/rewire)\r\n[![Coverage Status](https://img.shields.io/coveralls/jhnns/rewire.svg)](https://coveralls.io/r/jhnns/rewire)\r\n\r\n<br />\r\n\r\nInstallation\r\n------------\r\n\r\n`npm install rewire`\r\n\r\n<br />\r\n\r\nExamples\r\n--------\r\n\r\nImagine you want to test this module:\r\n\r\n```javascript\r\n// lib/myModule.js\r\n\r\n// With rewire you can change all these variables\r\nvar fs = require(\"fs\"),\r\n    http = require(\"http\"),\r\n    someOtherVar = \"hi\",\r\n    myPrivateVar = 1;\r\n\r\nfunction readSomethingFromFileSystem(cb) {\r\n    // But no scoped variables\r\n    var path = \"/somewhere/on/the/disk\";\r\n\r\n    console.log(\"Reading from file system ...\");\r\n    fs.readFile(path, \"utf8\", cb);\r\n}\r\n\r\nexports.readSomethingFromFileSystem = readSomethingFromFileSystem;\r\n```\r\n\r\nNow within your test module:\r\n\r\n```javascript\r\n// test/myModule.test.js\r\n\r\nvar rewire = require(\"rewire\");\r\n\r\n// rewire acts exactly like require.\r\nvar myModule = rewire(\"../lib/myModule.js\");\r\n\r\n// Just with one difference:\r\n// Your module will now export a special setter and getter for private variables.\r\nmyModule.__set__(\"myPrivateVar\", 123);\r\nmyModule.__get__(\"myPrivateVar\"); // = 123\r\n\r\n// This allows you to mock almost everything within the module e.g. the fs-module.\r\n// Just pass the variable name as first parameter and your mock as second.\r\nmyModule.__set__(\"fs\", {\r\n    readFile: function (path, encoding, cb) {\r\n        cb(null, \"Success!\");\r\n    }\r\n});\r\nmyModule.readSomethingFromFileSystem(function (err, data) {\r\n    console.log(data); // = Success!\r\n});\r\n\r\n// You can set different variables with one call.\r\nmyModule.__set__({\r\n    fs: fsMock,\r\n    http: httpMock,\r\n    someOtherVar: \"hello\"\r\n});\r\n\r\n// You may also override globals. These changes are only within the module, so\r\n// you don't have to be concerned that other modules are influenced by your mock.\r\nmyModule.__set__({\r\n    console: {\r\n        log: function () { /* be quiet */ }\r\n    },\r\n    process: {\r\n        argv: [\"testArg1\", \"testArg2\"]\r\n    }\r\n});\r\n\r\n// But be careful, if you do something like this you'll change your global\r\n// console instance.\r\nmyModule.__set__(\"console.log\", function () { /* be quiet */ });\r\n\r\n// There is another difference to require:\r\n// Every call of rewire() returns a new instance.\r\nrewire(\"./myModule.js\") === rewire(\"./myModule.js\"); // = false\r\n```\r\n\r\n<br />\r\n\r\n##API\r\n\r\n###rewire(filename): rewiredModule\r\n\r\n- *filename*: <br/>\r\nPath to the module that shall be rewired. Use it exactly like require().\r\n\r\n###rewiredModule.&#95;&#95;set&#95;&#95;(name, value)\r\n\r\n- *name*: <br/>\r\nName of the variable to set. The variable should be global or defined with `var` in the top-leve scope of the module.\r\n- *value*: <br/>\r\nThe value to set.\r\n\r\n###rewiredModule.&#95;&#95;set&#95;&#95;(env)\r\n- *env*: <br/>\r\nTakes all keys as variable names and sets the values respectively.\r\n\r\n###rewiredModule.&#95;&#95;get&#95;&#95;(name): value\r\n\r\nReturns the private variable.\r\n\r\n<br />\r\n\r\n##Client-Side Bundlers\r\n\r\n###webpack\r\nSee [rewire-webpack](https://github.com/jhnns/rewire-webpack)\r\n\r\n###browserify\r\nIf you're using browserify and want to use rewire with browserify [please let me know](https://github.com/jhnns/rewire/issues/13).\r\n\r\n<br />\r\n\r\n##License\r\n\r\nMIT\r\n",
  "readmeFilename": "README.md",
  "_id": "rewire@2.0.1",
  "_from": "rewire@~2.0.0"
}
